/*
 * QEMU model of the PMU_LOCAL Power Management Unit Local Register File
 *
 * Copyright (c) 2014 Xilinx Inc.
 *
 * Autogenerated by xregqemu.py 2014-09-01.
 * Written by Edgar E. Iglesias.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include "qemu/osdep.h"
#include "hw/sysbus.h"
#include "hw/register-dep.h"
#include "qemu/bitops.h"
#include "qemu/log.h"

#include "hw/fdt_generic_util.h"

#ifndef XILINX_PMU_LOCAL_ERR_DEBUG
#define XILINX_PMU_LOCAL_ERR_DEBUG 0
#endif

#define TYPE_XILINX_PMU_LOCAL "xlnx.pmu-local"

#define XILINX_PMU_LOCAL(obj) \
     OBJECT_CHECK(PMULocal, (obj), TYPE_XILINX_PMU_LOCAL)

DEP_REG32(ACPU0_PWR_CNTRL, 0x0)
    DEP_FIELD(ACPU0_PWR_CNTRL, ISOLATION, 1, 4)
    DEP_FIELD(ACPU0_PWR_CNTRL, PWR_GATES, 4, 0)
DEP_REG32(ACPU0_PWR_STATUS, 0x4)
    DEP_FIELD(ACPU0_PWR_STATUS, PWR_GATES, 4, 0)
DEP_REG32(ACPU1_PWR_CNTRL, 0x10)
    DEP_FIELD(ACPU1_PWR_CNTRL, ISOLATION, 1, 4)
    DEP_FIELD(ACPU1_PWR_CNTRL, PWR_GATES, 4, 0)
DEP_REG32(ACPU1_PWR_STATUS, 0x14)
    DEP_FIELD(ACPU1_PWR_STATUS, PWR_GATES, 4, 0)
DEP_REG32(ACPU2_PWR_CNTRL, 0x20)
    DEP_FIELD(ACPU2_PWR_CNTRL, ISOLATION, 1, 4)
    DEP_FIELD(ACPU2_PWR_CNTRL, PWR_GATES, 4, 0)
DEP_REG32(ACPU2_PWR_STATUS, 0x24)
    DEP_FIELD(ACPU2_PWR_STATUS, PWR_GATES, 4, 0)
DEP_REG32(ACPU3_PWR_CNTRL, 0x30)
    DEP_FIELD(ACPU3_PWR_CNTRL, ISOLATION, 1, 4)
    DEP_FIELD(ACPU3_PWR_CNTRL, PWR_GATES, 4, 0)
DEP_REG32(ACPU3_PWR_STATUS, 0x34)
    DEP_FIELD(ACPU3_PWR_STATUS, PWR_GATES, 4, 0)
DEP_REG32(PP0_PWR_CNTRL, 0x40)
    DEP_FIELD(PP0_PWR_CNTRL, ISOLATION, 1, 4)
    DEP_FIELD(PP0_PWR_CNTRL, PWR_GATES, 4, 0)
DEP_REG32(PP0_PWR_STATUS, 0x44)
    DEP_FIELD(PP0_PWR_STATUS, PWR_GATES, 4, 0)
DEP_REG32(PP1_PWR_CNTRL, 0x48)
    DEP_FIELD(PP1_PWR_CNTRL, ISOLATION, 1, 4)
    DEP_FIELD(PP1_PWR_CNTRL, PWR_GATES, 4, 0)
DEP_REG32(PP1_PWR_STATUS, 0x4c)
    DEP_FIELD(PP1_PWR_STATUS, PWR_GATES, 4, 0)
DEP_REG32(USB0_PWR_CNTRL, 0x60)
    DEP_FIELD(USB0_PWR_CNTRL, ISOLATION, 1, 4)
    DEP_FIELD(USB0_PWR_CNTRL, PWR_GATES, 4, 0)
DEP_REG32(USB0_PWR_STATUS, 0x64)
    DEP_FIELD(USB0_PWR_STATUS, PWR_GATES, 4, 0)
DEP_REG32(USB1_PWR_CNTRL, 0x70)
    DEP_FIELD(USB1_PWR_CNTRL, ISOLATION, 1, 4)
    DEP_FIELD(USB1_PWR_CNTRL, PWR_GATES, 4, 0)
DEP_REG32(USB1_PWR_STATUS, 0x74)
    DEP_FIELD(USB1_PWR_STATUS, PWR_GATES, 4, 0)
DEP_REG32(RPU_PWR_CNTRL, 0x80)
    DEP_FIELD(RPU_PWR_CNTRL, ISOLATION, 1, 4)
    DEP_FIELD(RPU_PWR_CNTRL, PWR_GATES, 4, 0)
DEP_REG32(RPU_PWR_STATUS, 0x84)
    DEP_FIELD(RPU_PWR_STATUS, PWR_GATES, 4, 0)
DEP_REG32(L2_PWR_CNTRL, 0xb0)
    DEP_FIELD(L2_PWR_CNTRL, BANK0, 1, 0)
DEP_REG32(L2_RET_CNTRL, 0xb4)
    DEP_FIELD(L2_RET_CNTRL, BANK0, 1, 0)
DEP_REG32(L2_CE_CNTRL, 0xb8)
    DEP_FIELD(L2_CE_CNTRL, BANK0, 1, 0)
DEP_REG32(L2_PWR_STATUS, 0xbc)
    DEP_FIELD(L2_PWR_STATUS, BANK0, 1, 0)
DEP_REG32(OCM_PWR_CNTRL, 0xc0)
    DEP_FIELD(OCM_PWR_CNTRL, BANK3, 1, 24)
    DEP_FIELD(OCM_PWR_CNTRL, BANK2, 1, 16)
    DEP_FIELD(OCM_PWR_CNTRL, BANK1, 1, 8)
    DEP_FIELD(OCM_PWR_CNTRL, BANK0, 1, 0)
DEP_REG32(OCM_RET_CNTRL, 0xc4)
    DEP_FIELD(OCM_RET_CNTRL, BANK3, 1, 3)
    DEP_FIELD(OCM_RET_CNTRL, BANK2, 1, 2)
    DEP_FIELD(OCM_RET_CNTRL, BANK1, 1, 1)
    DEP_FIELD(OCM_RET_CNTRL, BANK0, 1, 0)
DEP_REG32(OCM_CE_CNTRL, 0xc8)
    DEP_FIELD(OCM_CE_CNTRL, BANK3, 1, 3)
    DEP_FIELD(OCM_CE_CNTRL, BANK2, 1, 2)
    DEP_FIELD(OCM_CE_CNTRL, BANK1, 1, 1)
    DEP_FIELD(OCM_CE_CNTRL, BANK0, 1, 0)
DEP_REG32(OCM_PWR_STATUS, 0xcc)
    DEP_FIELD(OCM_PWR_STATUS, BANK3, 1, 24)
    DEP_FIELD(OCM_PWR_STATUS, BANK2, 1, 16)
    DEP_FIELD(OCM_PWR_STATUS, BANK1, 1, 8)
    DEP_FIELD(OCM_PWR_STATUS, BANK0, 1, 0)
DEP_REG32(TCM_PWR_CNTRL, 0xd0)
    DEP_FIELD(TCM_PWR_CNTRL, TCMB1, 1, 24)
    DEP_FIELD(TCM_PWR_CNTRL, TCMA1, 1, 16)
    DEP_FIELD(TCM_PWR_CNTRL, TCMB0, 1, 8)
    DEP_FIELD(TCM_PWR_CNTRL, TCMA0, 1, 0)
DEP_REG32(TCM_RET_CNTRL, 0xd4)
    DEP_FIELD(TCM_RET_CNTRL, TCMB1, 1, 3)
    DEP_FIELD(TCM_RET_CNTRL, TCMA1, 1, 2)
    DEP_FIELD(TCM_RET_CNTRL, TCMB0, 1, 1)
    DEP_FIELD(TCM_RET_CNTRL, TCMA0, 1, 0)
DEP_REG32(TCM_CE_CNTRL, 0xd8)
    DEP_FIELD(TCM_CE_CNTRL, TCMB1, 1, 3)
    DEP_FIELD(TCM_CE_CNTRL, TCMA1, 1, 2)
    DEP_FIELD(TCM_CE_CNTRL, TCMB0, 1, 1)
    DEP_FIELD(TCM_CE_CNTRL, TCMA0, 1, 0)
DEP_REG32(TCM_PWR_STATUS, 0xdc)
    DEP_FIELD(TCM_PWR_STATUS, TCMB1, 1, 24)
    DEP_FIELD(TCM_PWR_STATUS, TCMA1, 1, 16)
    DEP_FIELD(TCM_PWR_STATUS, TCMB0, 1, 8)
    DEP_FIELD(TCM_PWR_STATUS, TCMA0, 1, 0)
DEP_REG32(DOMAIN_ISO_CNTRL, 0xf0)
    DEP_FIELD(DOMAIN_ISO_CNTRL, LP_FP_LOCKED, 1, 31)
    DEP_FIELD(DOMAIN_ISO_CNTRL, FP_PL, 1, 5)
    DEP_FIELD(DOMAIN_ISO_CNTRL, LP_PL_PCAP, 1, 4)
    DEP_FIELD(DOMAIN_ISO_CNTRL, LP_PL_Non_PCAP, 1, 3)
    DEP_FIELD(DOMAIN_ISO_CNTRL, LP_FP_2, 1, 2)
    DEP_FIELD(DOMAIN_ISO_CNTRL, LP_FP_1, 1, 1)
    DEP_FIELD(DOMAIN_ISO_CNTRL, PMU, 1, 0)
DEP_REG32(LOC_PWR_STATE, 0x100)
    DEP_FIELD(LOC_PWR_STATE, USB1, 1, 21)
    DEP_FIELD(LOC_PWR_STATE, USB0, 1, 20)
    DEP_FIELD(LOC_PWR_STATE, OCM_BANK3, 1, 19)
    DEP_FIELD(LOC_PWR_STATE, OCM_BANK2, 1, 18)
    DEP_FIELD(LOC_PWR_STATE, OCM_BANK1, 1, 17)
    DEP_FIELD(LOC_PWR_STATE, OCM_BANK0, 1, 16)
    DEP_FIELD(LOC_PWR_STATE, TCM1B, 1, 15)
    DEP_FIELD(LOC_PWR_STATE, TCM1A, 1, 14)
    DEP_FIELD(LOC_PWR_STATE, TCM0B, 1, 13)
    DEP_FIELD(LOC_PWR_STATE, TCM0A, 1, 12)
    DEP_FIELD(LOC_PWR_STATE, R5_1, 1, 11)
    DEP_FIELD(LOC_PWR_STATE, R5_0, 1, 10)
    DEP_FIELD(LOC_PWR_STATE, L2, 1, 7)
    DEP_FIELD(LOC_PWR_STATE, GPU_PP1, 1, 5)
    DEP_FIELD(LOC_PWR_STATE, GPU_PP0, 1, 4)
    DEP_FIELD(LOC_PWR_STATE, ACPU3, 1, 3)
    DEP_FIELD(LOC_PWR_STATE, ACPU2, 1, 2)
    DEP_FIELD(LOC_PWR_STATE, ACPU1, 1, 1)
    DEP_FIELD(LOC_PWR_STATE, ACPU0, 1, 0)
DEP_REG32(LOC_AUX_PWR_STATE, 0x104)
    DEP_FIELD(LOC_AUX_PWR_STATE, ACPU3_EMUL, 1, 31)
    DEP_FIELD(LOC_AUX_PWR_STATE, ACPU2_EMUL, 1, 30)
    DEP_FIELD(LOC_AUX_PWR_STATE, ACPU1_EMUL, 1, 29)
    DEP_FIELD(LOC_AUX_PWR_STATE, ACPU0_EMUL, 1, 28)
    DEP_FIELD(LOC_AUX_PWR_STATE, RPU_EMUL, 1, 27)
    DEP_FIELD(LOC_AUX_PWR_STATE, OCM_BANK3, 1, 19)
    DEP_FIELD(LOC_AUX_PWR_STATE, OCM_BANK2, 1, 18)
    DEP_FIELD(LOC_AUX_PWR_STATE, OCM_BANK1, 1, 17)
    DEP_FIELD(LOC_AUX_PWR_STATE, OCM_BANK0, 1, 16)
    DEP_FIELD(LOC_AUX_PWR_STATE, TCM1B, 1, 15)
    DEP_FIELD(LOC_AUX_PWR_STATE, TCM1A, 1, 14)
    DEP_FIELD(LOC_AUX_PWR_STATE, TCM0B, 1, 13)
    DEP_FIELD(LOC_AUX_PWR_STATE, TCM0A, 1, 12)
    DEP_FIELD(LOC_AUX_PWR_STATE, L2, 1, 7)
DEP_REG32(LOCAL_RESET, 0x200)
    DEP_FIELD(LOCAL_RESET, CSU_RST, 1, 0)
DEP_REG32(LOCAL_CNTRL, 0x204)
    DEP_FIELD(LOCAL_CNTRL, BUS_CLK_DIS, 1, 0)
DEP_REG32(GPO1_READ, 0x214)
    DEP_FIELD(GPO1_READ, MIO_GPO, 6, 0)
DEP_REG32(GPO2_READ, 0x218)
    DEP_FIELD(GPO2_READ, DAP_RPU_WAKE_ACK, 1, 9)
    DEP_FIELD(GPO2_READ, DAP_FP_WAKE_ACK, 1, 8)
DEP_REG32(GPO3_READ, 0x21c)
DEP_REG32(GPI1_MASK, 0x224)
    DEP_FIELD(GPI1_MASK, APB_AIB_ERROR, 1, 31)
    DEP_FIELD(GPI1_MASK, AXI_AIB_ERROR, 1, 30)
    DEP_FIELD(GPI1_MASK, ERROR_REG2_INT, 1, 29)
    DEP_FIELD(GPI1_MASK, ERROR_REG1_INT, 1, 28)
    DEP_FIELD(GPI1_MASK, DBG_ACPU3_PWRUP_REQ, 1, 23)
    DEP_FIELD(GPI1_MASK, DBG_ACPU2_PWRUP_REQ, 1, 22)
    DEP_FIELD(GPI1_MASK, DBG_ACPU1_PWRUP_REQ, 1, 21)
    DEP_FIELD(GPI1_MASK, DBG_ACPU0_PWRUP_REQ, 1, 20)
    DEP_FIELD(GPI1_MASK, FPD_WAKE_GIC_PROX, 1, 16)
    DEP_FIELD(GPI1_MASK, MIO_WAKE, 6, 10)
    DEP_FIELD(GPI1_MASK, DAP_RPU_WAKE, 1, 9)
    DEP_FIELD(GPI1_MASK, DAP_FP_WAKE, 1, 8)
    DEP_FIELD(GPI1_MASK, USB1_WAKE, 1, 7)
    DEP_FIELD(GPI1_MASK, USB0_WAKE, 1, 6)
    DEP_FIELD(GPI1_MASK, R5_1_WAKE, 1, 5)
    DEP_FIELD(GPI1_MASK, R5_0_WAKE, 1, 4)
    DEP_FIELD(GPI1_MASK, ACPU3_WAKE, 1, 3)
    DEP_FIELD(GPI1_MASK, ACPU2_WAKE, 1, 2)
    DEP_FIELD(GPI1_MASK, ACPU1_WAKE, 1, 1)
    DEP_FIELD(GPI1_MASK, ACPU0_WAKE, 1, 0)
DEP_REG32(GPI2_MASK, 0x228)
    DEP_FIELD(GPI2_MASK, DBG_ACPU3_RST_REQ, 1, 23)
    DEP_FIELD(GPI2_MASK, DBG_ACPU2_RST_REQ, 1, 22)
    DEP_FIELD(GPI2_MASK, DBG_ACPU1_RST_REQ, 1, 21)
    DEP_FIELD(GPI2_MASK, DBG_ACPU0_RST_REQ, 1, 20)
    DEP_FIELD(GPI2_MASK, CP_ACPU3_RST_REQ, 1, 19)
    DEP_FIELD(GPI2_MASK, CP_ACPU2_RST_REQ, 1, 18)
    DEP_FIELD(GPI2_MASK, CP_ACPU1_RST_REQ, 1, 17)
    DEP_FIELD(GPI2_MASK, CP_ACPU0_RST_REQ, 1, 16)
    DEP_FIELD(GPI2_MASK, FP_LP_PWRDWN_ACK, 1, 6)
    DEP_FIELD(GPI2_MASK, R5_1_PWRDWN_REQ, 1, 5)
    DEP_FIELD(GPI2_MASK, R5_0_PWRDWN_REQ, 1, 4)
    DEP_FIELD(GPI2_MASK, ACPU3_PWRDWN_REQ, 1, 3)
    DEP_FIELD(GPI2_MASK, ACPU2_PWRDWN_REQ, 1, 2)
    DEP_FIELD(GPI2_MASK, ACPU1_PWRDWN_REQ, 1, 1)
    DEP_FIELD(GPI2_MASK, ACPU0_PWRDWN_REQ, 1, 0)
DEP_REG32(GPI3_MASK, 0x22c)
DEP_REG32(LOCAL_GEN_STORAGE0, 0x300)
DEP_REG32(LOCAL_GEN_STORAGE1, 0x304)
DEP_REG32(LOCAL_GEN_STORAGE2, 0x308)
DEP_REG32(LOCAL_GEN_STORAGE3, 0x30c)
DEP_REG32(PERS_LOC_GEN_STORAGE0, 0x310)
DEP_REG32(PERS_LOC_GEN_STORAGE1, 0x314)
DEP_REG32(PERS_LOC_GEN_STORAGE2, 0x318)
DEP_REG32(PERS_LOC_GEN_STORAGE3, 0x31c)
DEP_REG32(ADDR_ERROR_STATUS, 0x320)
    DEP_FIELD(ADDR_ERROR_STATUS, STATUS, 1, 0)
DEP_REG32(ADDR_ERROR_INT_MASK, 0x324)
    DEP_FIELD(ADDR_ERROR_INT_MASK, MASK, 1, 0)
DEP_REG32(ADDR_ERROR_INT_EN, 0x328)
    DEP_FIELD(ADDR_ERROR_INT_EN, EN, 1, 0)
DEP_REG32(ADDR_ERROR_INT_DIS, 0x32c)
    DEP_FIELD(ADDR_ERROR_INT_DIS, _, 1, 0)
DEP_REG32(MBISR_CNTRL, 0x330)
    DEP_FIELD(MBISR_CNTRL, FPD_GROUP, 1, 5)
    DEP_FIELD(MBISR_CNTRL, ENABLE, 1, 0)
DEP_REG32(MBISR_STATUS, 0x334)
    DEP_FIELD(MBISR_STATUS, PASS, 1, 4)
    DEP_FIELD(MBISR_STATUS, DONE, 1, 0)
DEP_REG32(PMU_PB_ERR, 0x338)
    DEP_FIELD(PMU_PB_ERR, PBERR_FLAG, 1, 31)
    DEP_FIELD(PMU_PB_ERR, PBERR_DATA, 31, 0)
DEP_REG32(PMU_SERV_ERR, 0x33c)
    DEP_FIELD(PMU_SERV_ERR, FWERR, 4, 28)
    DEP_FIELD(PMU_SERV_ERR, SERVERR_FLAG, 1, 23)
    DEP_FIELD(PMU_SERV_ERR, SERVERR_DATA, 20, 0)
DEP_REG32(PWR_ACK_ERR_LPD, 0x340)
DEP_REG32(PWR_ACK_ERR_FPD, 0x344)
DEP_REG32(SERV_LOGCLR_ERR, 0x348)
DEP_REG32(LOGCLR_TRIG, 0x350)
    DEP_FIELD(LOGCLR_TRIG, FP, 1, 17)
    DEP_FIELD(LOGCLR_TRIG, LP, 1, 16)
    DEP_FIELD(LOGCLR_TRIG, USB1, 1, 13)
    DEP_FIELD(LOGCLR_TRIG, USB0, 1, 12)
    DEP_FIELD(LOGCLR_TRIG, RPU, 1, 10)
    DEP_FIELD(LOGCLR_TRIG, PP1, 1, 7)
    DEP_FIELD(LOGCLR_TRIG, PP0, 1, 6)
    DEP_FIELD(LOGCLR_TRIG, ACPU3, 1, 3)
    DEP_FIELD(LOGCLR_TRIG, ACPU2, 1, 2)
    DEP_FIELD(LOGCLR_TRIG, ACPU1, 1, 1)
    DEP_FIELD(LOGCLR_TRIG, ACPU0, 1, 0)
DEP_REG32(LOGCLR_ACK, 0x354)
    DEP_FIELD(LOGCLR_ACK, FP, 1, 17)
    DEP_FIELD(LOGCLR_ACK, LP, 1, 16)
    DEP_FIELD(LOGCLR_ACK, USB1, 1, 13)
    DEP_FIELD(LOGCLR_ACK, USB0, 1, 12)
    DEP_FIELD(LOGCLR_ACK, RPU, 1, 10)
    DEP_FIELD(LOGCLR_ACK, PP1, 1, 7)
    DEP_FIELD(LOGCLR_ACK, PP0, 1, 6)
    DEP_FIELD(LOGCLR_ACK, ACPU3, 1, 3)
    DEP_FIELD(LOGCLR_ACK, ACPU2, 1, 2)
    DEP_FIELD(LOGCLR_ACK, ACPU1, 1, 1)
    DEP_FIELD(LOGCLR_ACK, ACPU0, 1, 0)
DEP_REG32(APU_WFI_STATUS, 0x360)
    DEP_FIELD(APU_WFI_STATUS, L2_WFI, 1, 16)
    DEP_FIELD(APU_WFI_STATUS, ACPU3_WFI, 1, 3)
    DEP_FIELD(APU_WFI_STATUS, ACPU2_WFI, 1, 2)
    DEP_FIELD(APU_WFI_STATUS, ACPU1_WFI, 1, 1)
    DEP_FIELD(APU_WFI_STATUS, ACPU0_WFI, 1, 0)
DEP_REG32(ECO_1, 0x400)
DEP_REG32(ECO_2, 0x404)

#define R_MAX (R_ECO_2 + 1)

typedef struct PMULocal {
    SysBusDevice parent_obj;
    MemoryRegion iomem;
    qemu_irq irq_addr_error;
    qemu_irq fpd_pwr_cntrl;

    uint32_t regs[R_MAX];
    DepRegisterInfo regs_info[R_MAX];
} PMULocal;

static void addr_error_update_irq(PMULocal *s)
{
    bool pending = s->regs[R_ADDR_ERROR_STATUS] & ~s->regs[R_ADDR_ERROR_INT_MASK];
    qemu_set_irq(s->irq_addr_error, pending);
}

static void addr_error_status_postw(DepRegisterInfo *reg, uint64_t val64)
{
    PMULocal *s = XILINX_PMU_LOCAL(reg->opaque);
    addr_error_update_irq(s);
}

static uint64_t addr_error_int_en_prew(DepRegisterInfo *reg, uint64_t val64)
{
    PMULocal *s = XILINX_PMU_LOCAL(reg->opaque);
    uint32_t val = val64;

    s->regs[R_ADDR_ERROR_INT_MASK] &= ~val;
    addr_error_update_irq(s);
    return 0;
}

static uint64_t addr_error_int_dis_prew(DepRegisterInfo *reg, uint64_t val64)
{
    PMULocal *s = XILINX_PMU_LOCAL(reg->opaque);
    uint32_t val = val64;

    s->regs[R_ADDR_ERROR_INT_MASK] |= val;
    addr_error_update_irq(s);
    return 0;
}

struct PwrStateMap {
    bool end;
    uint64_t addr;
    uint32_t mask;
    unsigned int bit;
    bool xor;
};

static struct {
    bool end;
    uint64_t addr;
    unsigned int bit;
    uint32_t mask;
    struct PwrStateMap *map;
} power_reg_map [] = {
    {   .addr = A_ACPU0_PWR_CNTRL, .bit = 0, .mask = 0xf,
        .map = (struct PwrStateMap[]) {
            { .addr = A_ACPU0_PWR_STATUS, .bit = 0 },
            { .end = true }
        }
    },
    {   .addr = A_ACPU1_PWR_CNTRL, .bit = 0, .mask = 0xf,
        .map = (struct PwrStateMap[]) {
            { .addr = A_ACPU1_PWR_STATUS, .bit = 0 },
            { .end = true }
        }
    },
    {   .addr = A_ACPU2_PWR_CNTRL, .bit = 0, .mask = 0xf,
        .map = (struct PwrStateMap[]) {
            { .addr = A_ACPU2_PWR_STATUS, .bit = 0 },
            { .end = true }
        }
    },
    {   .addr = A_ACPU3_PWR_CNTRL, .bit = 0, .mask = 0xf,
        .map = (struct PwrStateMap[]) {
            { .addr = A_ACPU3_PWR_STATUS, .bit = 0 },
            { .end = true }
        }
    },
    {   .addr = A_PP0_PWR_CNTRL, .bit = 0, .mask = 0xf,
        .map = (struct PwrStateMap[]) {
            { .addr = A_PP0_PWR_STATUS, .bit = 0 },
            { .end = true }
        }
    },
    {   .addr = A_PP1_PWR_CNTRL, .bit = 0, .mask = 0xf,
        .map = (struct PwrStateMap[]) {
            { .addr = A_PP1_PWR_STATUS, .bit = 0 },
            { .end = true }
        }
    },
    {   .addr = A_USB0_PWR_CNTRL, .bit = 0, .mask = 0xf,
        .map = (struct PwrStateMap[]) {
            { .addr = A_USB0_PWR_STATUS, .bit = 0 },
            { .end = true }
        }
    },
    {   .addr = A_USB1_PWR_CNTRL, .bit = 0, .mask = 0xf,
        .map = (struct PwrStateMap[]) {
            { .addr = A_USB1_PWR_STATUS, .bit = 0 },
            { .end = true }
        }
    },
    {   .addr = A_RPU_PWR_CNTRL, .bit = 0, .mask = 0xf,
        .map = (struct PwrStateMap[]) {
            { .addr = A_RPU_PWR_STATUS, .bit = 0 },
            { .end = true }
        }
    },

    /* RAMs.  */
    {   .addr = A_L2_PWR_CNTRL, .bit = 0, .mask = 0x1,
        .map = (struct PwrStateMap[]) {
            { .addr = A_L2_PWR_STATUS, .bit = 0 },
            { .end = true }
        }
    },
    {   .addr = A_OCM_PWR_CNTRL, .bit = 0, .mask = 0x01010101,
        .map = (struct PwrStateMap[]) {
            { .addr = A_OCM_PWR_STATUS, .bit = 0 },
            { .end = true }
        }
    },
    {   .addr = A_TCM_PWR_CNTRL, .bit = 0, .mask = 0x01010101,
        .map = (struct PwrStateMap[]) {
            { .addr = A_TCM_PWR_STATUS, .bit = 0 },
            { .end = true }
        }
    },
    { .end = true }
};

static void prop_power_gate_postw(DepRegisterInfo *reg, uint64_t val64)
{
    PMULocal *s = XILINX_PMU_LOCAL(reg->opaque);
    uint64_t addr = reg->access->decode.addr;
    uint32_t val32 = val64;
    unsigned int i, n;
    uint32_t src_val;

    for (i = 0; !power_reg_map[i].end; i++) {
        if (addr != power_reg_map[i].addr) {
            continue;
        }
        src_val = val32 & (power_reg_map[i].mask << power_reg_map[i].bit);

        for (n = 0; !power_reg_map[i].map[n].end; n++) {
            uint64_t dst_addr = power_reg_map[i].map[n].addr;
            unsigned int dst_bit = power_reg_map[i].map[n].bit;
            uint32_t dst_mask;
            uint32_t dst_val;

            dst_mask = power_reg_map[i].mask << dst_bit;
            if (power_reg_map[i].map[n].mask) {
                dst_mask = power_reg_map[i].map[n].mask << dst_bit;
            }
            dst_val = src_val ^ power_reg_map[i].map[n].xor;
            dst_val <<= dst_bit;

            s->regs[dst_addr / 4] &= ~dst_mask;
            s->regs[dst_addr / 4] |= dst_val;
        }
    }
}

#define FPD_ISOLATION_MASK \
    ( R_DOMAIN_ISO_CNTRL_LP_FP_1_MASK |	\
      R_DOMAIN_ISO_CNTRL_LP_FP_2_MASK |	\
      R_DOMAIN_ISO_CNTRL_FP_PL_MASK )

/* Used to control FPD power state, depending on the state of the isolation
 * bits.
 * FIXME: At the moment, this looks like the best place from which to control
 * the state of the FPD. If a better location is found, this should be moved.
 */
static void domain_iso_cntrl_postw(DepRegisterInfo *reg, uint64_t val64)
{
    PMULocal *s = XILINX_PMU_LOCAL(reg->opaque);
    uint32_t val = val64;

    if ((val & FPD_ISOLATION_MASK) == FPD_ISOLATION_MASK) {
        qemu_set_irq(s->fpd_pwr_cntrl, 0);
    } else {
        qemu_set_irq(s->fpd_pwr_cntrl, 1);
    }
}

static DepRegisterAccessInfo pmu_local_regs_info[] = {
#define ACPU_PWR_REGDEF(n) \
    {   .name = "ACPU" #n "_PWR_CNTRL", \
        .decode.addr = A_ACPU ## n ## _PWR_CNTRL, \
        .reset = 0xf, \
        .rsvd = 0xffffffe0, \
        .ro = 0xffffffe0, \
        .post_write = prop_power_gate_postw, \
        .gpios = (DepRegisterGPIOMapping[]) { \
            { .name = "ACPU" #n "_PWR_CNTRL", .bit_pos = 0, .width = 1 }, \
            {}, \
        } \
    },{ .name = "ACPU" #n "_PWR_STATUS", \
        .decode.addr = A_ACPU ## n ## _PWR_STATUS, \
        .reset = 0xf, \
        .rsvd = 0xfffffff0, \
        .ro = 0xffffffff, \
    }
    ACPU_PWR_REGDEF(0),
    ACPU_PWR_REGDEF(1),
    ACPU_PWR_REGDEF(2),
    ACPU_PWR_REGDEF(3),
      { .name = "PP0_PWR_CNTRL",  .decode.addr = A_PP0_PWR_CNTRL,
        .reset = 0xf,
        .rsvd = 0xffffffe0,
        .ro = 0xffffffe0,
        .post_write = prop_power_gate_postw,
        .gpios = (DepRegisterGPIOMapping[]) {
            { .name = "PP0_PWR_CNTRL", .bit_pos = 0, .width = 1 },
            {},
        }
    },{ .name = "PP0_PWR_STATUS",  .decode.addr = A_PP0_PWR_STATUS,
        .reset = 0xf,
        .rsvd = 0xfffffff0,
        .ro = 0xffffffff,
    },{ .name = "PP1_PWR_CNTRL",  .decode.addr = A_PP1_PWR_CNTRL,
        .reset = 0xf,
        .rsvd = 0xffffffe0,
        .ro = 0xffffffe0,
        .post_write = prop_power_gate_postw,
        .gpios = (DepRegisterGPIOMapping[]) {
            { .name = "PP1_PWR_CNTRL", .bit_pos = 0, .width = 1 },
            {},
        }
    },{ .name = "PP1_PWR_STATUS",  .decode.addr = A_PP1_PWR_STATUS,
        .reset = 0xf,
        .rsvd = 0xfffffff0,
        .ro = 0xffffffff,
    },{ .name = "USB0_PWR_CNTRL",  .decode.addr = A_USB0_PWR_CNTRL,
        .reset = 0xf,
        .rsvd = 0xffffffe0,
        .ro = 0xffffffe0,
        .post_write = prop_power_gate_postw,
        .gpios = (DepRegisterGPIOMapping[]) {
            { .name = "USB0_PWR_CNTRL", .bit_pos = 0, .width = 1 },
            {},
        }
    },{ .name = "USB0_PWR_STATUS",  .decode.addr = A_USB0_PWR_STATUS,
        .reset = 0xf,
        .rsvd = 0xfffffff0,
        .ro = 0xffffffff,
    },{ .name = "USB1_PWR_CNTRL",  .decode.addr = A_USB1_PWR_CNTRL,
        .reset = 0xf,
        .rsvd = 0xffffffe0,
        .ro = 0xffffffe0,
        .post_write = prop_power_gate_postw,
        .gpios = (DepRegisterGPIOMapping[]) {
            { .name = "USB1_PWR_CNTRL", .bit_pos = 0, .width = 1 },
            {},
        }
    },{ .name = "USB1_PWR_STATUS",  .decode.addr = A_USB1_PWR_STATUS,
        .reset = 0xf,
        .rsvd = 0xfffffff0,
        .ro = 0xffffffff,
    },{ .name = "RPU_PWR_CNTRL",  .decode.addr = A_RPU_PWR_CNTRL,
        .reset = 0xf,
        .rsvd = 0xffffffe0,
        .ro = 0xffffffe0,
        .post_write = prop_power_gate_postw,
        .gpios = (DepRegisterGPIOMapping[]) {
            { .name = "RPU_PWR_CNTRL", .bit_pos = 0, .width = 1 },
            {},
        }
    },{ .name = "RPU_PWR_STATUS",  .decode.addr = A_RPU_PWR_STATUS,
        .reset = 0xf,
        .rsvd = 0xfffffff0,
        .ro = 0xffffffff,
    },{ .name = "L2_PWR_CNTRL",  .decode.addr = A_L2_PWR_CNTRL,
        .reset = 0x1,
        .rsvd = 0xfffffffe,
        .ro = 0xfffffffe,
        .post_write = prop_power_gate_postw,
        .gpios = (DepRegisterGPIOMapping[]) {
            { .name = "L2_PWR_CNTRL", .bit_pos = 0, .width = 1 },
            {},
        }
    },{ .name = "L2_RET_CNTRL",  .decode.addr = A_L2_RET_CNTRL,
        .rsvd = 0xfffffffe,
        .ro = 0xfffffffe,
        .gpios = (DepRegisterGPIOMapping[]) {
            { .name = "L2_RET_CNTRL", .bit_pos = 0, .width = 1 },
            {},
        }
    },{ .name = "L2_CE_CNTRL",  .decode.addr = A_L2_CE_CNTRL,
        .reset = 0x1,
        .rsvd = 0xfffffffe,
        .ro = 0xfffffffe,
    },{ .name = "L2_PWR_STATUS",  .decode.addr = A_L2_PWR_STATUS,
        .reset = 0x1,
        .rsvd = 0xfffffffe,
        .ro = 0xffffffff,
    },{ .name = "OCM_PWR_CNTRL",  .decode.addr = A_OCM_PWR_CNTRL,
        .reset = 0x1010101,
        .rsvd = 0xfefefefe,
        .ro = 0xfefefefe,
        .post_write = prop_power_gate_postw,
        .gpios = (DepRegisterGPIOMapping[]) {
            { .name = "OCM_PWR_CNTRL_BANK0", .bit_pos = 0, .width = 1 },
            { .name = "OCM_PWR_CNTRL_BANK1", .bit_pos = 8, .width = 1 },
            { .name = "OCM_PWR_CNTRL_BANK2", .bit_pos = 16, .width = 1 },
            { .name = "OCM_PWR_CNTRL_BANK3", .bit_pos = 24, .width = 1 },
            {},
        }
    },{ .name = "OCM_RET_CNTRL",  .decode.addr = A_OCM_RET_CNTRL,
        .rsvd = 0xfffffff0,
        .ro = 0xfffffff0,
        .gpios = (DepRegisterGPIOMapping[]) {
            { .name = "OCM_RET_CNTRL_BANK0", .bit_pos = 0, .width = 1 },
            { .name = "OCM_RET_CNTRL_BANK1", .bit_pos = 1, .width = 1 },
            { .name = "OCM_RET_CNTRL_BANK2", .bit_pos = 2, .width = 1 },
            { .name = "OCM_RET_CNTRL_BANK3", .bit_pos = 3, .width = 1 },
            {},
        }
    },{ .name = "OCM_CE_CNTRL",  .decode.addr = A_OCM_CE_CNTRL,
        .reset = 0xf,
        .rsvd = 0xfffffff0,
        .ro = 0xfffffff0,
    },{ .name = "OCM_PWR_STATUS",  .decode.addr = A_OCM_PWR_STATUS,
        .reset = 0x1010101,
        .rsvd = 0xfefefefe,
        .ro = 0xffffffff,
    },{ .name = "TCM_PWR_CNTRL",  .decode.addr = A_TCM_PWR_CNTRL,
        .reset = 0x1010101,
        .rsvd = 0xfefefefe,
        .ro = 0xfefefefe,
        .post_write = prop_power_gate_postw,
        .gpios = (DepRegisterGPIOMapping[]) {
            { .name = "TCM_PWR_CNTRL_A0", .bit_pos = 0, .width = 1 },
            { .name = "TCM_PWR_CNTRL_B0", .bit_pos = 8, .width = 1 },
            { .name = "TCM_PWR_CNTRL_A1", .bit_pos = 16, .width = 1 },
            { .name = "TCM_PWR_CNTRL_B1", .bit_pos = 24, .width = 1 },
            {},
        }
    },{ .name = "TCM_RET_CNTRL",  .decode.addr = A_TCM_RET_CNTRL,
        .rsvd = 0xfffffff0,
        .ro = 0xfffffff0,
        .gpios = (DepRegisterGPIOMapping[]) {
            { .name = "TCM_RET_CNTRL_A0", .bit_pos = 0, .width = 1 },
            { .name = "TCM_RET_CNTRL_B0", .bit_pos = 1, .width = 1 },
            { .name = "TCM_RET_CNTRL_A1", .bit_pos = 2, .width = 1 },
            { .name = "TCM_RET_CNTRL_B1", .bit_pos = 3, .width = 1 },
            {},
        }
    },{ .name = "TCM_CE_CNTRL",  .decode.addr = A_TCM_CE_CNTRL,
        .reset = 0xf,
        .rsvd = 0xfffffff0,
        .ro = 0xfffffff0,
    },{ .name = "TCM_PWR_STATUS",  .decode.addr = A_TCM_PWR_STATUS,
        .reset = 0x1010101,
        .rsvd = 0xfefefefe,
        .ro = 0xffffffff,
    },{ .name = "DOMAIN_ISO_CNTRL",  .decode.addr = A_DOMAIN_ISO_CNTRL,
        .reset = 0x00000028,
        .rsvd = 0x7fffffc0,
        .ro = 0x7fffffc0,
        .post_write = domain_iso_cntrl_postw,
    },{ .name = "LOC_PWR_STATE",  .decode.addr = A_LOC_PWR_STATE,
        .reset = 0x3ffcbf,
        .rsvd = 0xffc00340,
        .ro = 0xffc00340,
    },{ .name = "LOC_AUX_PWR_STATE",  .decode.addr = A_LOC_AUX_PWR_STATE,
        .reset = 0xff080,
        .rsvd = 0x7f00f7f,
        .ro = 0x7f00f00,
    },{ .name = "LOCAL_RESET",  .decode.addr = A_LOCAL_RESET,
        .reset = 0x1,
        .rsvd = 0xfffffffe,
        .ro = 0xfffffffe,
        .inhibit_reset = 1u << 31,
        .gpios = (DepRegisterGPIOMapping[]) {
            { .name = "CSU_RST", .bit_pos = 0, .width = 1 },
            {},
        }
    },{ .name = "LOCAL_CNTRL",  .decode.addr = A_LOCAL_CNTRL,
        .rsvd = 0xfffffffe,
        .ro = 0xfffffffe,
    },{ .name = "GPO1_READ",  .decode.addr = A_GPO1_READ,
        .rsvd = 0xffffffc0,
        .ro = 0xffffffff,
    },{ .name = "GPO2_READ",  .decode.addr = A_GPO2_READ,
        .rsvd = 0xfffffcff,
        .ro = 0xffffffff,
    },{ .name = "GPO3_READ",  .decode.addr = A_GPO3_READ,
        .ro = 0xffffffff,
    },{ .name = "GPI1_MASK",  .decode.addr = A_GPI1_MASK,
        .rsvd = 0xf0e0000,
        .ro = 0xf0e0000,
        .gpios = (DepRegisterGPIOMapping[]) {
            { .name = "GPI1_ENABLE", .bit_pos = 0, .width = 32 },
            {},
        }
    },{ .name = "GPI2_MASK",  .decode.addr = A_GPI2_MASK,
        .rsvd = 0xff00ff80,
        .ro = 0xff00ff80,
        .gpios = (DepRegisterGPIOMapping[]) {
            { .name = "GPI2_ENABLE", .bit_pos = 0, .width = 32 },
            {},
        }
    },{ .name = "GPI3_MASK",  .decode.addr = A_GPI3_MASK,
    },{ .name = "LOCAL_GEN_STORAGE0",  .decode.addr = A_LOCAL_GEN_STORAGE0,
    },{ .name = "LOCAL_GEN_STORAGE1",  .decode.addr = A_LOCAL_GEN_STORAGE1,
    },{ .name = "LOCAL_GEN_STORAGE2",  .decode.addr = A_LOCAL_GEN_STORAGE2,
    },{ .name = "LOCAL_GEN_STORAGE3",  .decode.addr = A_LOCAL_GEN_STORAGE3,
    },{ .name = "PERS_LOC_GEN_STORAGE0",  .decode.addr = A_PERS_LOC_GEN_STORAGE0,
    },{ .name = "PERS_LOC_GEN_STORAGE1",  .decode.addr = A_PERS_LOC_GEN_STORAGE1,
    },{ .name = "PERS_LOC_GEN_STORAGE2",  .decode.addr = A_PERS_LOC_GEN_STORAGE2,
    },{ .name = "PERS_LOC_GEN_STORAGE3",  .decode.addr = A_PERS_LOC_GEN_STORAGE3,
    },{ .name = "ADDR_ERROR_STATUS",  .decode.addr = A_ADDR_ERROR_STATUS,
        .w1c = 0x1,
        .post_write = addr_error_status_postw,
    },{ .name = "ADDR_ERROR_INT_MASK",  .decode.addr = A_ADDR_ERROR_INT_MASK,
        .reset = 0x1,
        .ro = 0x1,
    },{ .name = "ADDR_ERROR_INT_EN",  .decode.addr = A_ADDR_ERROR_INT_EN,
        .pre_write = addr_error_int_en_prew,
    },{ .name = "ADDR_ERROR_INT_DIS",  .decode.addr = A_ADDR_ERROR_INT_DIS,
        .pre_write = addr_error_int_dis_prew,
    },{ .name = "MBISR_CNTRL",  .decode.addr = A_MBISR_CNTRL,
        .rsvd = 0xffffffde,
        .ro = 0xffffffde,
    },{ .name = "MBISR_STATUS",  .decode.addr = A_MBISR_STATUS,
        .rsvd = 0xffffffee,
        .ro = 0xffffffff,
    },{ .name = "PMU_PB_ERR",  .decode.addr = A_PMU_PB_ERR,
    },{ .name = "PMU_SERV_ERR",  .decode.addr = A_PMU_SERV_ERR,
        .rsvd = 0xf700000,
        .ro = 0xf700000,
    },{ .name = "PWR_ACK_ERR_LPD",  .decode.addr = A_PWR_ACK_ERR_LPD,
    },{ .name = "PWR_ACK_ERR_FPD",  .decode.addr = A_PWR_ACK_ERR_FPD,
    },{ .name = "SERV_LOGCLR_ERR",  .decode.addr = A_SERV_LOGCLR_ERR,
    },{ .name = "LOGCLR_TRIG",  .decode.addr = A_LOGCLR_TRIG,
        .rsvd = 0xfffccb30,
    },{ .name = "LOGCLR_ACK",  .decode.addr = A_LOGCLR_ACK,
        .rsvd = 0xfffccb30,
        .ro = 0xffffffff,
    },{ .name = "APU_WFI_STATUS",  .decode.addr = A_APU_WFI_STATUS,
        .rsvd = 0xfffefff0,
        .ro = 0xffffffff,
    },{ .name = "ECO_1",  .decode.addr = A_ECO_1,
    },{ .name = "ECO_2",  .decode.addr = A_ECO_2,
    }
};

static void pmu_local_reset(DeviceState *dev)
{
    PMULocal *s = XILINX_PMU_LOCAL(dev);
    unsigned int i;

    for (i = 0; i < ARRAY_SIZE(s->regs_info); ++i) {
        dep_register_reset(&s->regs_info[i]);
    }

    /*
     * since post_write is not called on dep_register_reset, we have to manually
     * call the post_write function for the DOMAIN_ISO_CNTRL register to
     * ensure that the FPD power state is updated correctly on reset
     */
    domain_iso_cntrl_postw(&s->regs_info[R_DOMAIN_ISO_CNTRL],
                            s->regs[R_DOMAIN_ISO_CNTRL]);

    addr_error_update_irq(s);
}

static uint64_t pmu_local_read(void *opaque, hwaddr addr, unsigned size)
{
    PMULocal *s = XILINX_PMU_LOCAL(opaque);
    DepRegisterInfo *r = &s->regs_info[addr / 4];

    if (!r->data) {
        qemu_log("%s: Decode error: read from %" HWADDR_PRIx "\n",
                 object_get_canonical_path(OBJECT(s)),
                 addr);
        DEP_AF_DP32(s->regs, ADDR_ERROR_STATUS, STATUS, true);
        addr_error_update_irq(s);
        return 0;
    }
    return dep_register_read(r);
}

static void pmu_local_write(void *opaque, hwaddr addr, uint64_t value,
                      unsigned size)
{
    PMULocal *s = XILINX_PMU_LOCAL(opaque);
    DepRegisterInfo *r = &s->regs_info[addr / 4];

    if (!r->data) {
        qemu_log("%s: Decode error: write to %" HWADDR_PRIx "=%" PRIx64 "\n",
                 object_get_canonical_path(OBJECT(s)),
                 addr, value);
        DEP_AF_DP32(s->regs, ADDR_ERROR_STATUS, STATUS, true);
        addr_error_update_irq(s);
        return;
    }
    dep_register_write(r, value, ~0);
}

static const MemoryRegionOps pmu_local_ops = {
    .read = pmu_local_read,
    .write = pmu_local_write,
    .endianness = DEVICE_LITTLE_ENDIAN,
    .valid = {
        .min_access_size = 4,
        .max_access_size = 4,
    },
};

static void pmu_local_realize(DeviceState *dev, Error **errp)
{
    PMULocal *s = XILINX_PMU_LOCAL(dev);
    const char *prefix = object_get_canonical_path(OBJECT(dev));
    unsigned int i;

    for (i = 0; i < ARRAY_SIZE(pmu_local_regs_info); ++i) {
        DepRegisterInfo *r = &s->regs_info[pmu_local_regs_info[i].decode.addr/4];

        *r = (DepRegisterInfo) {
            .data = (uint8_t *)&s->regs[
                    pmu_local_regs_info[i].decode.addr/4],
            .data_size = sizeof(uint32_t),
            .access = &pmu_local_regs_info[i],
            .debug = XILINX_PMU_LOCAL_ERR_DEBUG,
            .prefix = prefix,
            .opaque = s,
        };
        dep_register_init(r);
        qdev_pass_all_gpios(DEVICE(r), dev);
    }
    qdev_init_gpio_out_named(dev, &s->fpd_pwr_cntrl, "fpd_pwr_cntrl", 1);
}

static void pmu_local_init(Object *obj)
{
    PMULocal *s = XILINX_PMU_LOCAL(obj);
    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);

    memory_region_init_io(&s->iomem, obj, &pmu_local_ops, s,
                          TYPE_XILINX_PMU_LOCAL, R_MAX * 4);
    sysbus_init_mmio(sbd, &s->iomem);
    sysbus_init_irq(sbd, &s->irq_addr_error);
}

static const VMStateDescription vmstate_pmu_local = {
    .name = TYPE_XILINX_PMU_LOCAL,
    .version_id = 1,
    .minimum_version_id = 1,
    .minimum_version_id_old = 1,
    .fields = (VMStateField[]) {
        VMSTATE_UINT32_ARRAY(regs, PMULocal, R_MAX),
        VMSTATE_END_OF_LIST(),
    }
};

static const FDTGenericGPIOSet pmu_local_controller_gpios[] = {
    {
       .names = &fdt_generic_gpio_name_set_gpio,
       .gpios = (FDTGenericGPIOConnection []) {
            { .name = "CSU_RST",   .fdt_index = 0 },
            { .name = "ACPU0_PWR_CNTRL",   .fdt_index = 1 },
            { .name = "ACPU1_PWR_CNTRL",   .fdt_index = 2 },
            { .name = "ACPU2_PWR_CNTRL",   .fdt_index = 3 },
            { .name = "ACPU3_PWR_CNTRL",   .fdt_index = 4 },
            { .name = "PP0_PWR_CNTRL",     .fdt_index = 5 },
            { .name = "PP1_PWR_CNTRL",     .fdt_index = 6 },
            { .name = "USB0_PWR_CNTRL",    .fdt_index = 7 },
            { .name = "USB1_PWR_CNTRL",    .fdt_index = 8 },
            { .name = "RPU_PWR_CNTRL",     .fdt_index = 9 },
            { .name = "L2_PWR_CNTRL",      .fdt_index = 10 },
            { .name = "L2_RET_CNTRL",      .fdt_index = 11 },
            { .name = "OCM_PWR_CNTRL_BANK0",    .fdt_index = 12 },
            { .name = "OCM_PWR_CNTRL_BANK1",    .fdt_index = 13 },
            { .name = "OCM_PWR_CNTRL_BANK2",    .fdt_index = 14 },
            { .name = "OCM_PWR_CNTRL_BANK3",    .fdt_index = 15 },
            { .name = "OCM_RET_CNTRL_BANK0",    .fdt_index = 16 },
            { .name = "OCM_RET_CNTRL_BANK1",    .fdt_index = 17 },
            { .name = "OCM_RET_CNTRL_BANK2",    .fdt_index = 18 },
            { .name = "OCM_RET_CNTRL_BANK3",    .fdt_index = 19 },
            { .name = "TCM_PWR_CNTRL_A0",     .fdt_index = 20 },
            { .name = "TCM_PWR_CNTRL_B0",     .fdt_index = 21 },
            { .name = "TCM_PWR_CNTRL_A1",     .fdt_index = 22 },
            { .name = "TCM_PWR_CNTRL_B1",     .fdt_index = 23 },
            { .name = "TCM_RET_CNTRL_A0",     .fdt_index = 24 },
            { .name = "TCM_RET_CNTRL_B0",     .fdt_index = 25 },
            { .name = "TCM_RET_CNTRL_A1",     .fdt_index = 26 },
            { .name = "TCM_RET_CNTRL_B1",     .fdt_index = 27 },
            { .name = "fpd_pwr_cntrl",          .fdt_index = 28},
            { .name = "GPI1_ENABLE",            .fdt_index = 29},
            { .name = "GPI2_ENABLE",            .fdt_index = 30},
            { },
       },
    },
    { },
};

static void pmu_local_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    FDTGenericGPIOClass *fggc = FDT_GENERIC_GPIO_CLASS(klass);

    dc->reset = pmu_local_reset;
    dc->realize = pmu_local_realize;
    dc->vmsd = &vmstate_pmu_local;
    fggc->controller_gpios = pmu_local_controller_gpios;
}

static const TypeInfo pmu_local_info = {
    .name          = TYPE_XILINX_PMU_LOCAL,
    .parent        = TYPE_SYS_BUS_DEVICE,
    .instance_size = sizeof(PMULocal),
    .class_init    = pmu_local_class_init,
    .instance_init = pmu_local_init,
    .interfaces    = (InterfaceInfo[]) {
        { TYPE_FDT_GENERIC_GPIO },
        { }
    },
};

static void pmu_local_register_types(void)
{
    type_register_static(&pmu_local_info);
}

type_init(pmu_local_register_types)
